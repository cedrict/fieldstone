\noindent
\includegraphics[height=1.25cm]{images/pictograms/replication}
\includegraphics[height=1.25cm]{images/pictograms/aspect_logo}
\includegraphics[height=1.25cm]{images/pictograms/benchmark}
\includegraphics[height=1.25cm]{images/pictograms/FEM}
\includegraphics[height=1.25cm]{images/pictograms/temperature}
\includegraphics[height=1.25cm]{images/pictograms/3d}
\includegraphics[height=1.25cm]{images/pictograms/paraview}
\includegraphics[height=1.25cm]{images/pictograms/clean}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{flushright} {\tiny {\color{gray} python\_codes/fieldstone\_20/text.tex}} \end{flushright}

\par\noindent\rule{\textwidth}{0.4pt}

\begin{center}
\inpython
{\small Code: \url{https://github.com/cedrict/fieldstone/tree/master/python_codes/fieldstone_20}}
\end{center}

\par\noindent\rule{\textwidth}{0.4pt}

Last revision: January 27th, 2026.

\par\noindent\rule{\textwidth}{0.4pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This three-dimensional benchmark was first proposed by \textcite{bucc94} (1994). 
It has been subsequently carried out in 
\textcite{tack94} (1994),
\textcite{trha98} (1998), 
\textcite{albe00} (2000),
\textcite{onmm06} (2006), 
\textcite{dawk11} (2011), 
\textcite{krhb12} (2012),
\textcite{thie14} (2014).
I here focus on Case 1 of the original article:  
an isoviscous bimodal convection experiment at $\Ranb=3\cdot 10^5$.

The domain is of size $a\times b\times h$ with $a=1.0079\cdot h$, $b=0.6283 \cdot h$ 
with $h=\SI{2700}{\km}$. It is filled with a Newtonian fluid 
characterised by $\rho_0=\SI{3300}{\kg\per\cubic\meter}$, 
$\alpha=10^{-5}~\si{\per\kelvin}$, 
$\eta=8.0198\times10^{23}~\si{\pascal\second}$, 
$k=3.564~\si{\watt\per\meter\per\kelvin}$, 
$C_p=1080~\si{\joule\per\kelvin\per\kg}$.
The gravity vector is set to $\vec{g}=(0,0,-10)\si{\meter\per\square\second}$.
The temperature is imposed at the bottom  ($T=3700~\si{\celsius}$) and at the top ($T=0~\si{\celsius}$).

Note that using these numbers (as provided in the original paper), we arrive at $\Ranb$=29967.01, which 
is not exactly $3\cdot10^5$ as announced, although the heat diffusivity $\kappa=k/\rho_0 C_p$ is 
{\it exactly} $10^{-6}~\si{\square\meter\per\second}$.

The various measurements presented in the article are listed hereafter:
\begin{itemize}
\item The Nusselt number $\Nunb$ computed at the top surface following:
\[
\Nunb = L_z \frac{\int\int_{z=L_z} \frac{\partial T}{\partial y} dx dy  }{\int \int_{z=0} T dx dy}.
\]
\item The root mean square velocity $\upnu_{rms}$ and the temperature mean square velocity $T_{rms}$.
\item The vertical velocity $w$ and temperature $T$ at points $\vec{r}_1=(0,0,L_z/2)$, 
$\vec{r}_2=(L_x,0,L_z/2)$, $\vec{r}_3=(0,L_y,L_z/2)$ and $\vec{r}_4=(L_x,L_y,L_z/2)$.
\item The vertical component of the heat flux $Q$ at the top surface  at all four corners. 
\end{itemize}

\begin{center}
\includegraphics[height=6cm]{python_codes/fieldstone_20/images/krhb12}
\includegraphics[height=6cm]{python_codes/fieldstone_20/images/elefant}\\
{\captionfont Left: 
Velocity field and isosurfaces of the temperature at steady state obtained 
with \aspect.\\ Taken from \textcite{krhb12} (2012).
Right: same, obtained with \elefant \cite{thie14}.}
\end{center}


\noindent Given the dimensions of the domain, here are resolutions 
that would yield (roughly) cubic elements:
\begin{center}
\begin{tabular}{l|lccccccc|}
domain size & \\
\hline
$a$=1.0079$\times$2700km & nelx= &16 &20 &24 &28 &32 &36 &40 \\  
$b$=0.6283$\times$2700km & nely= &10 &13 &15 &18 &20 &23 &25 \\
$h$=1.0000$\times$2700km & nelz= &16 &20 &24 &28 &32 &36 &40 \\  
\hline
\end{tabular}
\end{center}
Note that \lstinline{nelz} must be a multiple of four since we need to carry out measurements at 
locations characterised by $z=3L_z/4$ (technically not a requirement but it makes the 
measurement much easier).

%-------------------------
\subsection*{Methodology}

In what follows I highlight a few important points which are key to understanding how the code
is put together and works. 

\begin{verbatim}
load needed modules and functions
define parameters
build V grid (x_V,y_V,z_V)
build V connectivity (icon_V)
define b.c. for velocity (bc_fix_V,bc_val_V)
build T grid (x_T,y_T,z_T)
build T connectivity (icon_T)
define b.c. for temperature (bc_fix_T,bc_val_T)
initial temperature field
.------------------------> istep ---------------------.
|  build Kel,Gel,f,h                                  |
|  assemble them in A_fem,b_fem                       |
|  solve                                              |
|  split solution vector in u,v,w,p                   |
|  {u,v,w}=relax_V*{u,v,w}+(1-relax_V)*{u,v,w}        |
|  compute vrms                                       |
|  build A_fem, b_fem for temperature                 |
|  solve for temperature T                            |
|  T=relax_T*T+(1-relax_T)*T                          |
|  compute elemental strainrate                       |
|  compute nodal strainrate                           |
|  compute nodal pressure                             |
|  measure V and T at mid side edges, Nu ...          |
|  export to vtu and ascii files                      | 
.---------------------------<-------------------------.
\end{verbatim}

There are \lstinline{nn_V=nnx*nny*nnz} velocity nodes and 
\lstinline{nn_T=nn_V} temperature nodes.

The velocity grid is built: \lstinline{x_V, y_V, z_V, icon_V}, and 
these are copied in \lstinline{x_T, y_T, z_T, icon_T} for the temperature grid.  

The initial temperature field is built as follows:
\begin{lstlisting}
for i in range(0,nn_T):
   T[i]=(Temperature2-Temperature1)/Lz*z_T[i]+Temperature1 \
       +100*(np.cos(np.pi*x_T[i]/Lx) + np.cos(np.pi*y_T[i]/Ly))*np.sin(np.pi*z_T[i]/Lz)
\end{lstlisting}

The ${\bm C}$ matrix of Eq.~\eqref{MMM-eq:mixedC} (see {\tt manual.pdf}) is then built:
\begin{lstlisting}
c_mat = np.array([[2,0,0,0,0,0],\
                  [0,2,0,0,0,0],\
                  [0,0,2,0,0,0],\
                  [0,0,0,1,0,0],\
                  [0,0,0,0,1,0],\
                  [0,0,0,0,0,1]],dtype=np.float64) 
\end{lstlisting}

%.......................................
\subsubsection{Getting to steady state}  

In this case I am not so much interested in the path to steady state (i.e.
the intermediate values) since the published values/measurements are {\it at} steady state.
The mass and momentum conservation equations for incompressible Stokes flow do not 
contain a time derivative but the energy conservation equation does. 

At steady state the terms $\partial_t T$ is zero by definition so we must solve
the following equation\footnote{Adiabatic heating, shear heating and internal heating 
are not considered in the benchmark -- Boussinesq approximation} (see 
Section~\ref{MMM-ss:hte} of {\tt manual.pdf}):
\begin{equation}
\rho_0 C_p
\vec{\upnu}\cdot\vec\nabla T - {\vec \nabla} \cdot k {\vec \nabla} T = 0
\end{equation}
The Finite Element discretisation of this equation yields 
\[
({\bm K}_a + {\bm K}_d) \cdot \vec{T} = \vec{b}
\]
where $\vec{b}$ contains the boundary conditions.
This formulation is much simpler than the time-dependent one and avoids to discuss the choice
of time-discretisation algorithm altogether. 

I now have to solve three coupled equations:
\begin{eqnarray}
-{\vec \nabla}p + {\vec \nabla}\cdot (2 \eta \dot{\bm \varepsilon}^d ) + \rho(T) {\vec g} &=& \vec{0} \\
{\vec \nabla}\cdot{\vec \upnu} &=& 0 \\ 
\rho_0 C_p \vec{\upnu}\cdot\vec\nabla T - {\vec \nabla} \cdot k {\vec \nabla} T &=& 0 
\end{eqnarray}
I could then proceed to write the weak forms of these equations and cast these as we have done before, 
but this time considering velocity, pressure and temperature as unknowns of a (very) large system:
\[
\left(
\begin{array}{ccc}
\K & \G & . \\
\G^T & 0 & . \\
. & . & . 
\end{array}
\right)
\cdot
\left(
\begin{array}{c}
\vec{\cal V} \\ \vec{\cal P} \\ \vec{\cal T}
\end{array}
\right)
=
\left(
\begin{array}{c}
. \\ . \\ .
\end{array}
\right)
\]
Once this matrix is filled a single solve would then yield the steady state velocity, pressure and 
temperature fields! 

The term $\rho(T)$ will naturally end up in the (1,3) block of the assembled matrix as matrix ${\bm L}$.
The mass conservation equation in this form is independent of temperature so the (2,3) block 
will be zero. The diffusion term ${\bm K}_d$ naturally finds its way to the (3,3) 
block and since there is not occurence of pressure in the energy equation the (3,2) 
block will be zero. I then obtain:
\[
\left(
\begin{array}{ccc}
\K & \G & {\bm L} \\
\G^T & 0 & 0 \\
. & 0 & {\bm K}_d 
\end{array}
\right)
\cdot
\left(
\begin{array}{c}
V \\ P \\ T 
\end{array}
\right)
=
\left(
\begin{array}{c}
. \\ . \\ .
\end{array}
\right)
\]
The last remaining term is the advection term of the energy equation and it is a problematic one:
it features the product of the velocity by the temperature gradient. 
As such it is nonlinear and one cannot either put it in the (3,1) block nor in the (3,3) block,
which is why the problem is solved iteratively. The idea is simple: when solving the 
coupled mass and momentum equations, we assume temperature known, and when solving the energy equation
we assume the velocity field known. I can then alternatively solve one system and then the other, constantly 
updating the fields when re-building the matrices and right hand sides.

However, it is well known that a straightforward implementation of this algorithm does not 
work in practice, i.e. it fails to converge, which is why a relaxation scheme is often implemented:
\begin{enumerate}
\item Solve for velocity and pressure
\item relax velocity
\begin{lstlisting}
u=relax*u+(1-relax)*u_old
v=relax*v+(1-relax)*v_old
w=relax*w+(1-relax)*w_old
\end{lstlisting}
\item Solve for temperature
\item relax temperature
\begin{lstlisting}
T=relax*T+(1-relax)*T_old
\end{lstlisting}
\item check for convergence:
\begin{lstlisting}
if np.abs(Nu-Nu_old)<1.e-5:
   break
\end{lstlisting}
\item store old fields
\begin{lstlisting}
u_old=u
v_old=v
w_old=w
T_old=T
\end{lstlisting}
\end{enumerate}
The relaxation parameter \lstinline{relax} should be between 0 and 1.
In this case I found that a relaxation coefficient of 1 actually works.
Note that at the moment the same coefficient is used to relax both velocity and temperature, I have 
not explored different values for both (the code however showcases \lstlisting{relax_V}
and \lstlisting{relax_T}).

%........................................
\subsubsection*{Computing nodal derivatives}  

Another interesting approach here is how the strain rate is computed on the nodes as well as
the temperature gradient. The strain rate is not needed for the required measurements of this 
benchmark but the Nusselt number calculations require $\partial T/\partial z$ at the top
boundary.    
The idea is simple: loop over all elements, and for each element loop over its support nodes
(in this case the $2\times 2\times 2$ nodes of the $Q_1$), compute the required derivative 
there and add its contribution to the nodal field. Finally divide the obtained field by 
the number of elements each node is part of.

\begin{lstlisting}
    for iel in range(0,nel):
        for i in range(0,mV):
            [...]
            for k in range(0,mV):
                dT_dx += dNNNVdx[k]*T[iconV[k,iel]]
                dT_dy += dNNNVdy[k]*T[iconV[k,iel]]
                dT_dz += dNNNVdz[k]*T[iconV[k,iel]]
            # end for
            dTdxn[iconV[i,iel]]+=dT_dx
            dTdyn[iconV[i,iel]]+=dT_dy
            dTdzn[iconV[i,iel]]+=dT_dz
            c[iconV[i,iel]]+=1.
        # end for i
    # end for iel
    dTdxn/=c
    dTdyn/=c
    dTdzn/=c
\end{lstlisting}

%........................................
\subsubsection*{Jacobian estimates}  

Because the mesh is regular and all elements have the same size $h_x,h_y,x_z$
then the Jacobian of the transformation from an element to the reference element
is given by 
\[
{\bm J}=\left( \begin{array}{ccc}
h_x/2 & 0 & 0 \\
0 & h_y/2 & 0 \\
0 & 0 & h_z/2
\end{array} \right)
\qquad
|{\bm J}|=\frac{h_xh_yh_z}{8}
\]
Since these quantities are typically evaluated at all quadrature points 
there is a substantial CPU time save by precomputing these quantities only 
once before entering the matrix building loop:

\begin{lstlisting}
jcob=hx*hy*hz/8
jcbi=np.zeros((ndim,ndim),dtype=np.float64)
jcbi[0,0]=2/hx ; jcbi[0,1]=0    ; jcbi[0,2]=0
jcbi[1,0]=0    ; jcbi[1,1]=2/hy ; jcbi[1,2]=0
jcbi[2,0]=0    ; jcbi[2,1]=0    ; jcbi[2,2]=2/hz
\end{lstlisting}

The \lstlisting{} parameter controls whether or not this 'shortcut' is used.
This allows then for a timing comparison for the various parts of the 
code where the Jacobian is needed. 

\begin{center}
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/timings/build_energy.pdf}
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/timings/build_stokes.pdf}\\
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/timings/compute_sr.pdf}
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/timings/compute_vrms.pdf}
\end{center}
Unsurprisingly timings are substantially lower when the shortcut is used.


I also measure the solve time for good measure although we do not expect this 
time to depend on the Jacobian calculations at all:
\begin{center}
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/timings/solve_energy.pdf}
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/timings/solve_stokes.pdf}
\end{center}



\newpage
%.......................
\subsection*{Results}

Given how the code is written and how costly 3D simulations are in general, high resolution
cases take a long time to run, even using relaxation instead of time stepping. 
From the following figures it is obvious that the value of the relaxation parameter 
does not influence the final steady state value and that using a high value close or 
equal to one is probably the best option (0.9 seems to be best in this case). 

\begin{center}
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/Tavrg.pdf}\\
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/vrms.pdf}
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/Tmid.pdf}\\
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/Tm.pdf}
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/Nu.pdf}\\
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/hf1.pdf}
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/hf2.pdf}\\
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/wmid1.pdf}
\includegraphics[width=7.5cm]{python_codes/fieldstone_20/results/wmid2.pdf}
\end{center}

\newpage
The reported values for Busse et al. in the following table are taken from Table 3 
of \textcite{bucc94} (1994).
The reported values for this \stone are adimensionalised by means of a reference temperature (3700K),
a reference lengthscale 2700km, and a reference time $L_z^2/\kappa\sim 7.29e+18$s.
{\color{red} the table comes from krhb12 - i need to put the stone results next!}

\begin{center}
\begin{tabular}{lllllll}
\hline
                                & \aspect &      &       & Busse et al \cite{bucc94} & \stone  \\
Mesh size                       & Lz/24  & Lz/32 & Lz/48 & (best results)            & 24x12x32?  \\ 
\hline
$\Nunb$                         & 3.5539 &3.5447 & 3.5397 & $3.5374  \pm 0.0005$   \\
$v_{rms}$                       & 40.997 &40.999 &40.999  & $40.999  \pm 0.004$    \\
$\langle T\rangle$ at $0.75*Lz$ & 0.52148 & 0.52148&0.52148  & $0.52148 \pm 0.00003$  \\
$w(0,0,L_z/2)$     & 116.605 & 116.618 &  116.623  & $116.625 \pm 0.030$ \\
$w(L_x,0,L_z/2)$   & - &-&-& -\\
$w(L_x,L_y,L_z/2)$ & - &-&-& -\\
$w(0,L_y,L_z/2)$   &  &&& $40.500 \pm 0.030$ \\

$T(0,0,L_z/2)$     &  0.80126 & 0.80128 & 0.80129 & $0.80130 \pm 0.00005$ \\
$T(L_x,0,L_z/2)$   &  -&-&-& -\\
$T(L_x,L_y,L_z/2)$ &  -&-&-& -\\
$T(0,L_y,L_z/2)$   &  &&& $0.61876 \pm 0.00005$ \\
$dTdz(0,0,L_z)$    & 6.7679 & 6.7357 & 6.7189 & $6.7127 \pm 0.0500$ \\
$dTdz(L_x,0,L_z)$  &  & & & $1.5080 \pm 0.0500$ \\
$dTdz(L_x,L_y,L_z)$& 0.7237 & 0.7205 & 0.7174 & $0.7140 \pm 0.0500$ \\
$dTdz(0,L_y,L_z)$  &  & & & $3.1740 \pm 0.0500$ \\
\hline
\end{tabular}
\end{center}

\begin{center}
\includegraphics[width=5.5cm]{python_codes/fieldstone_20/results/24x12x32_1p0/u}
\includegraphics[width=5.5cm]{python_codes/fieldstone_20/results/24x12x32_1p0/v}
\includegraphics[width=5.5cm]{python_codes/fieldstone_20/results/24x12x32_1p0/w}\\
\includegraphics[width=5.5cm]{python_codes/fieldstone_20/results/24x12x32_1p0/vel}
\includegraphics[width=5.5cm]{python_codes/fieldstone_20/results/24x12x32_1p0/T}
\includegraphics[width=5.5cm]{python_codes/fieldstone_20/results/24x12x32_1p0/sr}\\
{\captionfont Results obtained on $24\times 12\times 32$ mesh}
\end{center}


